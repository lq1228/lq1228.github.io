<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Redux简介</title>
  <meta name="description" content=" Redux是一个可预测的JavaScript应用程序的状态容器">

  <link rel="stylesheet" href="/stylesheets/stylesheet.css">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://lq1228.github.io//front/article/2017/06/05/redux2.html">
  <link rel="alternate" type="application/rss+xml" title="lq1228.github.io" href="http://lq1228.github.io//feed.xml">
  <link rel="icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
</head>


  <body>

    <header class="main-header">
    <div class="inner">
        <h1>liqian</h1>
        <blockquote>
            <p>
            <p>
        </blockquote>
        <a href="https://github.com/lq1228" class="button"><small>Follow me on</small> GitHub</a>
    </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <nav>当前位置：<a href="/">首页</a> &gt; <a href="/front/article/2017/06/05/redux2.html">Redux简介</a></nav>
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Redux简介</h1>
    <p class="post-meta"><time datetime="2017-06-05T10:49:42+08:00" itemprop="datePublished">Jun 5, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。有两个方面，它没涉及。</p>

<ul>
    <li>代码结构</li>
    <li>组件之间的通信</li>
</ul>

<p>对于大型的复杂应用来说，这两方面恰恰是最关键的。因此，只用 React 没法写大型应用。</p>

<p>为了解决这个问题，2014年 Facebook 提出了 Flux 架构的概念，引发了很多的实现。2015年，Redux 出现，Redux是Flux思想的发展，同时避免了其复杂性，并吸取了Elm的解决思路，很短时间内就成为了最热门的前端架构。</p>

<p><a href="http://redux.js.org/">Redux官网</a></p>

<p>Redux是一个可预测的JavaScript应用程序的状态容器。</p>

<p>基于Redux可以编写在不同运行环境中（客户端，服务端，和原生程序）行为一致的应用程序，并便于测试的进行。此外，其提供了优秀的开发体验，比如实时刷新和时间旅行调试。</p>

<p>首先明确一点，Redux 是一个有用的架构，但不是非用不可。事实上，大多数情况，你可以不用它，只用 React 就够了。</p>

<p>曾经有人说过这样一句话。 “如果你不知道是否需要 Redux，那就是不需要它。”</p>

<p>Redux 的创造者 Dan Abramov 又补充了一句。 “只有遇到 React 实在解决不了的问题，你才需要 Redux 。”</p>

<h4 id="redux">不需要使用Redux的场景：</h4>
<ul>
    <li>简单说，如果你的UI层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。</li>
    <li>用户的使用方式非常简单，用户之间没有协作</li>
    <li> 不需要与服务器大量交互，也没有使用 WebSocket</li>
    <li> 视图层（View）只从单一来源获取数据</li>
</ul>

<h4 id="redux-">Redux 的适用场景：多交互、多数据源。</h4>
<ul>
    <li>用户的使用方式复杂</li>
    <li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li>
    <li>多个用户之间可以协作</li>
    <li>与服务器大量交互，或者使用了WebSocket</li>
    <li>View要从多个来源获取数据</li>
</ul>

<h4 id="redux-1">从组件角度看，如果你的应用有以下场景，可以考虑使用 Redux。</h4>
<ul>
    <li>某个组件的状态，需要共享</li>
    <li>某个状态需要在任何地方都可以拿到</li>
    <li>一个组件需要改变全局状态</li>
    <li>一个组件需要改变另一个组件的状态</li>
</ul>

<p>发生上面情况时，如果不使用 Redux 或者其他状态管理工具，不按照一定规律处理状态的读写，代码很快就会变成一团乱麻。你需要一种机制，可以在同一个地方查询状态、改变状态、传播状态的变化。</p>

<p>总之，不要把 Redux 当作万灵丹，如果你的应用没那么复杂，就没必要用它。另一方面，Redux 只是 Web 架构的一种解决方案，也可以选择其他方案。</p>

<h3 id="redux--1">Redux 核心原则</h3>

<ul>
    <li> 应用的整个状态树必须被存储在一个单例对象store中。</li>
    <li> 更新状态树的唯一方法是派发一个action对象来描述发生的情况。</li>
    <li> 特别需要指出的是，用来处理状态树更新的reducers函数必须是纯函数。</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">import</span> <span class="p">{</span> <span class="nx">createStore</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'redux'</span>

<span class="cm">/**
 * This is a reducer, a pure function with (state, action) =&gt; state signature.
 * It describes how an action transforms the state into the next state.
 *
 * The shape of the state is up to you: it can be a primitive, an array, an object,
 * or even an Immutable.js data structure. The only important part is that you should
 * not mutate the state object, but return a new object if the state changes.
 *
 * In this example, we use a `switch` statement and strings, but you can use a helper that
 * follows a different convention (such as function maps) if it makes sense for your
 * project.
**/</span>
<span class="kd">function</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="s1">'INCREMENT'</span><span class="err">:</span>
    <span class="k">return</span> <span class="nx">state</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">case</span> <span class="s1">'DECREMENT'</span><span class="err">:</span>
    <span class="k">return</span> <span class="nx">state</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="nl">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">state</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Create a Redux store holding the state of your app.</span>
<span class="c1">// Its API is { subscribe, dispatch, getState }.</span>
<span class="kd">let</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">createStore</span><span class="p">(</span><span class="nx">counter</span><span class="p">)</span>

<span class="c1">// You can use subscribe() to update the UI in response to state changes.</span>
<span class="c1">// Normally you'd use a view binding library (e.g. React Redux) rather than subscribe() directly.</span>
<span class="c1">// However it can also be handy to persist the current state in the localStorage.</span>

<span class="nx">store</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(()</span> <span class="o">=&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">store</span><span class="p">.</span><span class="nx">getState</span><span class="p">())</span>
<span class="p">)</span>

<span class="c1">// The only way to mutate the internal state is to dispatch an action.</span>
<span class="c1">// The actions can be serialized, logged or stored and later replayed.</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="s1">'INCREMENT'</span> <span class="p">})</span>
<span class="c1">// 1</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="s1">'INCREMENT'</span> <span class="p">})</span>
<span class="c1">// 2</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="s1">'DECREMENT'</span> <span class="p">})</span>
<span class="c1">// 1</span></code></pre></figure>

<p>在Redux中禁止直接修改状态，需要用一个简单的actions对象来描述修改。最后在reducer方法中如何处理整个程序的状态。</p>

<p>如果了解Flux，需要理解Redex和Flux的一个重要区别。Redux没有Dispatcher，也不支持多个store。在Redux中，只包含根reduce方法中处理的一个store对象单例。当你的应用复杂化的同时，不需要增加新的store对象，只需要将根reducer拆分为更小的reducer来独立处理状态树的不同部分。类似于React应用中只有一个根组件，但是其由更多的小组件组成。</p>

<p>在计数器应用中使用这种结构模式显得过于复杂，但当应用扩展到更大、更复杂的应用时将发现其优势。可以配合强大的开发者工具，以用来追踪action触发的每一次修改。可以记录用户会话，并通过重播每一个action重现操作场景。</p>

<p><a href="http://redux.js.org/">Redux</a> 有很好的文档，还有配套的小视频（<a href="https://egghead.io/courses/getting-started-with-redux">前30集</a>，<a href="https://egghead.io/courses/building-react-applications-with-idiomatic-redux">后30集</a>）。</p>

  </div>

</article>
<!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="/front/article/2017/06/05/redux2" data-title="Redux简介" data-url="/front/article/2017/06/05/redux2.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"lq1228"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
<!-- 多说公共JS代码 end -->

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="friend-link">
        <div class="friend-title">友情链接</div>
        
            <a href="https://bystep15.github.io/">
		宝宝树前端团队博客
	    </a>
	
            <a href="http://testudy.github.io/">
		胡继伟
	    </a>
	
            <a href="https://yj1438.github.io/">
		尹杰
	    </a>
	
            <a href="https://github.com/cnsnake11/blog">
		曹楠
	    </a>
	
            <a href="http://wumingli.github.io/">
		武明礼
	    </a>
	
            <a href="http://kouyun.me/">
		寇云
	    </a>
	
            <a href="http://brooch.me/">
		郑星宬
	    </a>
	
            <a href="http://zhanyouwei.com/">
		占友伟
	    </a>
	
            <a href="https://lilywei739.github.io">
		魏莉
	    </a>
	
            <a href="https://wangjiaoxia.github.io/">
		王娇霞
	    </a>
	
            <a href="">
		
	    </a>
	
    </div>

    <div class="copyright">
      <p>lq1228.github.io</p>
    </div>

  </div>

</footer>


  </body>

</html>
