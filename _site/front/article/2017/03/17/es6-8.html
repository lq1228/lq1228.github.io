<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>ES6语法之八（对象的扩展）</title>
  <meta name="description" content="对象的扩展">

  <link rel="stylesheet" href="/stylesheets/stylesheet.css">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://lq1228.github.io//front/article/2017/03/17/es6-8.html">
  <link rel="alternate" type="application/rss+xml" title="lq1228.github.io" href="http://lq1228.github.io//feed.xml">
  <link rel="icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
</head>


  <body>

    <header class="main-header">
    <div class="inner">
        <h1>liqian</h1>
        <blockquote>
            <p>
            <p>
        </blockquote>
        <a href="https://github.com/lq1228" class="button"><small>Follow me on</small> GitHub</a>
    </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <nav>当前位置：<a href="/">首页</a> &gt; <a href="/front/article/2017/03/17/es6-8.html">ES6语法之八（对象的扩展）</a></nav>
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">ES6语法之八（对象的扩展）</h1>
    <p class="post-meta"><time datetime="2017-03-17T10:49:42+08:00" itemprop="datePublished">Mar 17, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h3 id="section">1. 属性的简洁表示法</h3>

<p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">'bar'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="p">};</span>
<span class="nx">baz</span> <span class="c1">// {foo: "bar"}</span>

<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="p">{</span><span class="na">foo</span><span class="p">:</span> <span class="nx">foo</span><span class="p">};</span></code></pre></figure>

<p>上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">};</span>
<span class="p">}</span>

<span class="c1">// 等同于</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="nx">x</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="nx">y</span><span class="p">};</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// Object {x: 1, y: 2}</span></code></pre></figure>

<p>除了属性简写，方法也可以简写。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">"Hello!"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 等同于</span>

<span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">method</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">"Hello!"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>下面是一个实际的例子。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">birth</span> <span class="o">=</span> <span class="s1">'2000/01/01'</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">{</span>

  <span class="na">name</span><span class="p">:</span> <span class="s1">'张三'</span><span class="p">,</span>

  <span class="c1">//等同于birth: birth</span>
  <span class="nx">birth</span><span class="p">,</span>

  <span class="c1">// 等同于hello: function ()...</span>
  <span class="nx">hello</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'我的名字是'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="p">}</span>

<span class="p">};</span></code></pre></figure>

<p>这种写法用于函数的返回值，将会非常方便。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">getPoint</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">};</span>
<span class="p">}</span>

<span class="nx">getPoint</span><span class="p">()</span>
<span class="c1">// {x:1, y:10}</span></code></pre></figure>

<p>CommonJS模块输出变量，就非常合适使用简洁写法。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">ms</span> <span class="o">=</span> <span class="p">{};</span>

<span class="kd">function</span> <span class="nx">getItem</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">ms</span> <span class="p">?</span> <span class="nx">ms</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">:</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">setItem</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ms</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">clear</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">ms</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">getItem</span><span class="p">,</span> <span class="nx">setItem</span><span class="p">,</span> <span class="nx">clear</span> <span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">getItem</span><span class="p">:</span> <span class="nx">getItem</span><span class="p">,</span>
  <span class="na">setItem</span><span class="p">:</span> <span class="nx">setItem</span><span class="p">,</span>
  <span class="na">clear</span><span class="p">:</span> <span class="nx">clear</span>
<span class="p">};</span></code></pre></figure>

<p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">cart</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">_wheels</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>

  <span class="nx">get</span> <span class="nx">wheels</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_wheels</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="nx">set</span> <span class="nx">wheels</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">_wheels</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'数值太小了！'</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_wheels</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="kr">class</span> <span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// 等同于</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">'class'</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span></code></pre></figure>

<p>上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。</p>

<p>如果某个方法的值是一个Generator函数，前面需要加上星号。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="o">*</span> <span class="nx">m</span><span class="p">(){</span>
    <span class="k">yield</span> <span class="s1">'hello world'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<h3 id="section-1">2. 属性名表达式</h3>

<p>JavaScript语言定义对象的属性，有两种方法。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 方法一</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="c1">// 方法二</span>
<span class="nx">obj</span><span class="p">[</span><span class="s1">'a'</span> <span class="o">+</span> <span class="s1">'bc'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span></code></pre></figure>

<p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>

<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">foo</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">abc</span><span class="p">:</span> <span class="mi">123</span>
<span class="p">};</span></code></pre></figure>

<p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">propKey</span> <span class="o">=</span> <span class="s1">'foo'</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">propKey</span><span class="p">]:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">[</span><span class="s1">'a'</span> <span class="o">+</span> <span class="s1">'bc'</span><span class="p">]:</span> <span class="mi">123</span>
<span class="p">};</span></code></pre></figure>

<p>下面是另一个例子。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">lastWord</span> <span class="o">=</span> <span class="s1">'last word'</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">'first word'</span><span class="p">:</span> <span class="s1">'hello'</span><span class="p">,</span>
  <span class="p">[</span><span class="nx">lastWord</span><span class="p">]:</span> <span class="s1">'world'</span>
<span class="p">};</span>

<span class="nx">a</span><span class="p">[</span><span class="s1">'first word'</span><span class="p">]</span> <span class="c1">// "hello"</span>
<span class="nx">a</span><span class="p">[</span><span class="nx">lastWord</span><span class="p">]</span> <span class="c1">// "world"</span>
<span class="nx">a</span><span class="p">[</span><span class="s1">'last word'</span><span class="p">]</span> <span class="c1">// "world"</span></code></pre></figure>

<p>表达式还可以用于定义方法名。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="s1">'h'</span> <span class="o">+</span> <span class="s1">'ello'</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">'hi'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">hello</span><span class="p">()</span> <span class="c1">// hi</span></code></pre></figure>

<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 报错</span>
<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">'bar'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="s1">'abc'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">foo</span><span class="p">]</span> <span class="p">};</span>

<span class="c1">// 正确</span>
<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">'bar'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">foo</span><span class="p">]:</span> <span class="s1">'abc'</span><span class="p">};</span></code></pre></figure>

<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">keyA</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">};</span>
<span class="kr">const</span> <span class="nx">keyB</span> <span class="o">=</span> <span class="p">{</span><span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">};</span>

<span class="kr">const</span> <span class="nx">myObject</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">keyA</span><span class="p">]:</span> <span class="s1">'valueA'</span><span class="p">,</span>
  <span class="p">[</span><span class="nx">keyB</span><span class="p">]:</span> <span class="s1">'valueB'</span>
<span class="p">};</span>

<span class="nx">myObject</span> <span class="c1">// Object {[object Object]: "valueB"}</span></code></pre></figure>

<p>上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。</p>

<h3 id="name-">3. 方法的 name 属性</h3>

<p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">sayName</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'hello!'</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">.</span><span class="nx">name</span>   <span class="c1">// "sayName"</span></code></pre></figure>

<p>上面代码中，方法的name属性返回函数名（即方法名）。</p>

<p>如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">get</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{},</span>
  <span class="nx">set</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">name</span>
<span class="c1">// TypeError: Cannot read property 'name' of undefined</span>

<span class="kr">const</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">);</span>

<span class="nx">descriptor</span><span class="p">.</span><span class="nx">get</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// "get foo"</span>
<span class="nx">descriptor</span><span class="p">.</span><span class="nx">set</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// "set foo"</span></code></pre></figure>

<p>有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">(</span><span class="k">new</span> <span class="nb">Function</span><span class="p">()).</span><span class="nx">name</span> <span class="c1">// "anonymous"</span>

<span class="kd">var</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
<span class="nx">doSomething</span><span class="p">.</span><span class="nx">bind</span><span class="p">().</span><span class="nx">name</span> <span class="c1">// "bound doSomething"</span></code></pre></figure>

<p>如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">key1</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">'description'</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">key2</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">key1</span><span class="p">]()</span> <span class="p">{},</span>
  <span class="p">[</span><span class="nx">key2</span><span class="p">]()</span> <span class="p">{},</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">[</span><span class="nx">key1</span><span class="p">].</span><span class="nx">name</span> <span class="c1">// "[description]"</span>
<span class="nx">obj</span><span class="p">[</span><span class="nx">key2</span><span class="p">].</span><span class="nx">name</span> <span class="c1">// ""</span></code></pre></figure>

<p>上面代码中，key1对应的 Symbol 值有描述，key2没有。</p>

<h3 id="objectis">4. Object.is()</h3>

<p>ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>

<p>ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">)</span>
<span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">({},</span> <span class="p">{})</span>
<span class="c1">// false</span></code></pre></figure>

<p>不同之处只有两个：一是+0不等于-0，二是NaN等于自身。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">+</span><span class="mi">0</span> <span class="o">===</span> <span class="o">-</span><span class="mi">0</span> <span class="c1">//true</span>
<span class="kc">NaN</span> <span class="o">===</span> <span class="kc">NaN</span> <span class="c1">// false</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="kc">NaN</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true</span></code></pre></figure>

<p>ES5可以通过下面的代码，部署Object.is。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nb">Object</span><span class="p">,</span> <span class="s1">'is'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 针对+0 不等于 -0的情况</span>
      <span class="k">return</span> <span class="nx">x</span> <span class="o">!==</span> <span class="mi">0</span> <span class="o">||</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">x</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">y</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 针对NaN的情况</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">!==</span> <span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">!==</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">enumerable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span></code></pre></figure>

<h3 id="objectassign">5. Object.assign()</h3>

<h4 id="section-2">基本用法</h4>

<p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>

<span class="kd">var</span> <span class="nx">source1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">source2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source1</span><span class="p">,</span> <span class="nx">source2</span><span class="p">);</span>
<span class="nx">target</span> <span class="c1">// {a:1, b:2, c:3}</span></code></pre></figure>

<p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</p>

<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>

<span class="kd">var</span> <span class="nx">source1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">source2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source1</span><span class="p">,</span> <span class="nx">source2</span><span class="p">);</span>
<span class="nx">target</span> <span class="c1">// {a:1, b:2, c:3}</span></code></pre></figure>

<p>如果只有一个参数，Object.assign会直接返回该参数。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="nx">obj</span> <span class="c1">// true</span></code></pre></figure>

<p>如果该参数不是对象，则会先转成对象，然后返回。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">typeof</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// "object"</span></code></pre></figure>

<p>由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// 报错</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// 报错</span></code></pre></figure>

<p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">)</span> <span class="o">===</span> <span class="nx">obj</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="kc">null</span><span class="p">)</span> <span class="o">===</span> <span class="nx">obj</span> <span class="c1">// true</span></code></pre></figure>

<p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">v1</span> <span class="o">=</span> <span class="s1">'abc'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">v2</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">v3</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">v3</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// { "0": "a", "1": "b", "2": "c" }</span></code></pre></figure>

<p>上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// {[[PrimitiveValue]]: true}</span>
<span class="nb">Object</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1">//  {[[PrimitiveValue]]: 10}</span>
<span class="nb">Object</span><span class="p">(</span><span class="s1">'abc'</span><span class="p">)</span> <span class="c1">// {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}</span></code></pre></figure>

<p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被Object.assign拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>

<p>Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({</span><span class="na">b</span><span class="p">:</span> <span class="s1">'c'</span><span class="p">},</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">({},</span> <span class="s1">'invisible'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="na">value</span><span class="p">:</span> <span class="s1">'hello'</span>
  <span class="p">})</span>
<span class="p">)</span>
<span class="c1">// { b: 'c' }</span></code></pre></figure>

<p>上面代码中，Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。</p>

<p>属性名为Symbol值的属性，也会被Object.assign拷贝。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="s1">'b'</span> <span class="p">},</span> <span class="p">{</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">(</span><span class="s1">'c'</span><span class="p">)]:</span> <span class="s1">'d'</span> <span class="p">})</span>
<span class="c1">// { a: 'b', Symbol(c): 'd' }</span></code></pre></figure>

<h4 id="section-3">注意点</h4>

<p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="p">{</span><span class="na">b</span><span class="p">:</span> <span class="mi">1</span><span class="p">}};</span>
<span class="kd">var</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">obj1</span><span class="p">);</span>

<span class="nx">obj1</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// 2</span></code></pre></figure>

<p>上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>

<p>对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="s1">'c'</span><span class="p">,</span> <span class="na">d</span><span class="p">:</span> <span class="s1">'e'</span> <span class="p">}</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">source</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="s1">'hello'</span> <span class="p">}</span> <span class="p">}</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span>
<span class="c1">// { a: { b: 'hello' } }</span></code></pre></figure>

<p>上面代码中，target对象的a属性被source对象的a属性整个替换掉了，而不会得到{ a: { b: ‘hello’, d: ‘e’ } }的结果。这通常不是开发者想要的，需要特别小心。</p>

<p>有一些函数库提供Object.assign的定制版本（比如Lodash的_.defaultsDeep方法），可以解决浅拷贝的问题，得到深拷贝的合并。</p>

<p>注意，Object.assign可以用来处理数组，但是会把数组视为对象。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="c1">// [4, 5, 3]</span></code></pre></figure>

<p>上面代码中，Object.assign把数组视为属性名为0、1、2的对象，因此源数组的0号属性4覆盖了目标数组的0号属性1。</p>

<h4 id="section-4">常见用途</h4>

<p>Object.assign方法有很多用处。</p>

<p>（1）为对象添加属性</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。</p>

<p>（2）为对象添加方法</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">SomeClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">someMethod</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">···</span>
  <span class="p">},</span>
  <span class="nx">anotherMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="err">···</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// 等同于下面的写法</span>
<span class="nx">SomeClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">someMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">)</span> <span class="p">{</span>
  <span class="err">···</span>
<span class="p">};</span>
<span class="nx">SomeClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">anotherMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="err">···</span>
<span class="p">};</span></code></pre></figure>

<p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。</p>

<p>（3）克隆对象</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">clone</span><span class="p">(</span><span class="nx">origin</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">origin</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>

<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">clone</span><span class="p">(</span><span class="nx">origin</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">originProto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">origin</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">originProto</span><span class="p">),</span> <span class="nx">origin</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>（4）合并多个对象</p>

<p>将多个对象合并到某个对象。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">merge</span> <span class="o">=</span>
  <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">...</span><span class="nx">sources</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">...</span><span class="nx">sources</span><span class="p">);</span></code></pre></figure>

<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">merge</span> <span class="o">=</span>
  <span class="p">(...</span><span class="nx">sources</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="p">...</span><span class="nx">sources</span><span class="p">);</span></code></pre></figure>

<p>（5）为属性指定默认值</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">DEFAULTS</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">logLevel</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="na">outputFormat</span><span class="p">:</span> <span class="s1">'html'</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">processContent</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">options</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">DEFAULTS</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">options</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值。</p>

<p>注意，由于存在深拷贝的问题，DEFAULTS对象和options对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS对象的该属性很可能不起作用。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">DEFAULTS</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">url</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">host</span><span class="p">:</span> <span class="s1">'example.com'</span><span class="p">,</span>
    <span class="na">port</span><span class="p">:</span> <span class="mi">7070</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">processContent</span><span class="p">({</span> <span class="na">url</span><span class="p">:</span> <span class="p">{</span><span class="na">port</span><span class="p">:</span> <span class="mi">8000</span><span class="p">}</span> <span class="p">})</span>
<span class="c1">// {</span>
<span class="c1">//   url: {port: 8000}</span>
<span class="c1">// }</span></code></pre></figure>

<p>上面代码的原意是将url.port改成8000，url.host不变。实际结果却是options.url覆盖掉DEFAULTS.url，所以url.host就不存在了。</p>

<h3 id="section-5">6. 属性的可枚举性</h3>

<p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="mi">123</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">)</span>
<span class="c1">//  {</span>
<span class="c1">//    value: 123,</span>
<span class="c1">//    writable: true,</span>
<span class="c1">//    enumerable: true,</span>
<span class="c1">//    configurable: true</span>
<span class="c1">//  }</span></code></pre></figure>

<p>描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。</p>

<p>ES5有三个操作会忽略enumerable为false的属性。</p>

<p>for…in循环：只遍历对象自身的和继承的可枚举的属性
Object.keys()：返回对象自身的所有可枚举的属性的键名
JSON.stringify()：只串行化对象自身的可枚举的属性
ES6新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</p>

<p>这四个操作之中，只有for…in会返回继承的属性。实际上，引入enumerable的最初目的，就是让某些属性可以规避掉for…in操作。比如，对象原型的toString方法，以及数组的length属性，就通过这种手段，不会被for…in遍历到。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">'toString'</span><span class="p">).</span><span class="nx">enumerable</span>
<span class="c1">// false</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">([],</span> <span class="s1">'length'</span><span class="p">).</span><span class="nx">enumerable</span>
<span class="c1">// false</span></code></pre></figure>

<p>上面代码中，toString和length属性的enumerable都是false，因此for…in不会遍历到这两个继承自原型的属性。</p>

<p>另外，ES6规定，所有Class的原型的方法都是不可枚举的。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="kr">class</span> <span class="p">{</span><span class="nx">foo</span><span class="p">()</span> <span class="p">{}}.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">).</span><span class="nx">enumerable</span>
<span class="c1">// false</span></code></pre></figure>

<p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for…in循环，而用Object.keys()代替。</p>

<h3 id="section-6">7. 属性的遍历</h3>

<p>ES6一共有5种方法可以遍历对象的属性。</p>

<p>（1）for…in</p>

<p>for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</p>

<p>（2）Object.keys(obj)</p>

<p>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</p>

<p>（3）Object.getOwnPropertyNames(obj)</p>

<p>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</p>

<p>（4）Object.getOwnPropertySymbols(obj)</p>

<p>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。</p>

<p>（5）Reflect.ownKeys(obj)</p>

<p>Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</p>

<p>以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。</p>

<p>首先遍历所有属性名为数值的属性，按照数字排序。</p>

<p>其次遍历所有属性名为字符串的属性，按照生成时间排序。</p>

<p>最后遍历所有属性名为Symbol值的属性，按照生成时间排序。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">({</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">()]:</span><span class="mi">0</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="na">a</span><span class="p">:</span><span class="mi">0</span> <span class="p">})</span>
<span class="c1">// ['2', '10', 'b', 'a', Symbol()]</span></code></pre></figure>

<p>上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是Symbol属性。</p>

<h3 id="protoobjectsetprototypeofobjectgetprototypeof">8. __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h3>

<h4 id="proto">__proto__属性</h4>

<p>__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// es6的写法</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">method</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">someOtherObj</span><span class="p">;</span>

<span class="c1">// es5的写法</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">someOtherObj</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">method</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span></code></pre></figure>

<p>该属性没有写入 ES6 的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。</p>

<p>在实现上，<strong>proto__调用的是Object.prototype.__proto</strong>，具体实现如下。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">'__proto__'</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">_thisObj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">_thisObj</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="nx">set</span><span class="p">(</span><span class="nx">proto</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="k">this</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isObject</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isObject</span><span class="p">(</span><span class="nx">proto</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">status</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">proto</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">status</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">},</span>
<span class="p">});</span>
<span class="kd">function</span> <span class="nx">isObject</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>如果一个对象本身部署了__proto__属性，则该属性的值就是对象的原型。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">({</span> <span class="na">__proto__</span><span class="p">:</span> <span class="kc">null</span> <span class="p">})</span>
<span class="c1">// null</span></code></pre></figure>

<h4 id="objectsetprototypeof">Object.setPrototypeOf()</h4>

<p>Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 格式</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">object</span><span class="p">,</span> <span class="nx">prototype</span><span class="p">)</span>

<span class="c1">// 用法</span>
<span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">({},</span> <span class="kc">null</span><span class="p">);</span></code></pre></figure>

<p>该方法等同于下面的函数。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">proto</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>下面是一个例子。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">proto</span><span class="p">);</span>

<span class="nx">proto</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="nx">proto</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// 10</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">y</span> <span class="c1">// 20</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">z</span> <span class="c1">// 40</span></code></pre></figure>

<p>上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。</p>

<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{})</span> <span class="o">===</span> <span class="mi">1</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="p">{})</span> <span class="o">===</span> <span class="s1">'foo'</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="p">{})</span> <span class="o">===</span> <span class="kc">true</span> <span class="c1">// true</span></code></pre></figure>

<p>由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="p">{})</span>
<span class="c1">// TypeError: Object.setPrototypeOf called on null or undefined</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{})</span>
<span class="c1">// TypeError: Object.setPrototypeOf called on null or undefined</span></code></pre></figure>

<h4 id="objectgetprototypeof">Object.getPrototypeOf()</h4>

<p>该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span></code></pre></figure>

<p>下面是一个例子。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Rectangle</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">rec</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">();</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">rec</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span>
<span class="c1">// true</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">rec</span><span class="p">,</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">rec</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span>
<span class="c1">// false</span></code></pre></figure>

<p>如果参数不是对象，会被自动转为对象。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 等同于 Object.getPrototypeOf(Number(1))</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// Number {[[PrimitiveValue]]: 0}</span>

<span class="c1">// 等同于 Object.getPrototypeOf(String('foo'))</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="c1">// String {length: 0, [[PrimitiveValue]]: ""}</span>

<span class="c1">// 等同于 Object.getPrototypeOf(Boolean(true))</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="c1">// Boolean {[[PrimitiveValue]]: false}</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span> <span class="o">===</span> <span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Boolean</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span></code></pre></figure>

<p>如果参数是undefined或null，它们无法转为对象，所以会报错。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
<span class="c1">// TypeError: Cannot convert undefined or null to object</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span>
<span class="c1">// TypeError: Cannot convert undefined or null to object</span></code></pre></figure>

<h3 id="objectkeysobjectvaluesobjectentries">9. Object.keys()，Object.values()，Object.entries()</h3>

<h4 id="objectkeys">Object.keys()</h4>

<p>ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="s1">'bar'</span><span class="p">,</span> <span class="na">baz</span><span class="p">:</span> <span class="mi">42</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="c1">// ["foo", "baz"]</span></code></pre></figure>

<p>ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="p">{</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">values</span><span class="p">,</span> <span class="nx">entries</span><span class="p">}</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="nx">of</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="c1">// 'a', 'b', 'c'</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="nx">of</span> <span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 1, 2, 3</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="nx">of</span> <span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]);</span> <span class="c1">// ['a', 1], ['b', 2], ['c', 3]</span></code></pre></figure>

<h4 id="objectvalues">Object.values()</h4>

<p>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="s1">'bar'</span><span class="p">,</span> <span class="na">baz</span><span class="p">:</span> <span class="mi">42</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="c1">// ["bar", 42]</span></code></pre></figure>

<p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">100</span><span class="p">:</span> <span class="s1">'a'</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">'b'</span><span class="p">,</span> <span class="mi">7</span><span class="p">:</span> <span class="s1">'c'</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="c1">// ["b", "c", "a"]</span></code></pre></figure>

<p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。</p>

<p>Object.values只返回对象自身的可遍历属性。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">({},</span> <span class="p">{</span><span class="na">p</span><span class="p">:</span> <span class="p">{</span><span class="na">value</span><span class="p">:</span> <span class="mi">42</span><span class="p">}});</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// []</span></code></pre></figure>

<p>上面代码中，Object.create方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的enumerable默认是false，Object.values不会返回这个属性。只要把enumerable改成true，Object.values就会返回属性p的值。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">({},</span> <span class="p">{</span><span class="na">p</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// [42]</span></code></pre></figure>

<p>Object.values会过滤属性名为 Symbol 值的属性。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">({</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">()]:</span> <span class="mi">123</span><span class="p">,</span> <span class="na">foo</span><span class="p">:</span> <span class="s1">'abc'</span> <span class="p">});</span>
<span class="c1">// ['abc']</span></code></pre></figure>

<p>如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>	<span class="c1">// ['f', 'o', 'o']</span></code></pre></figure>

<p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，Object.values返回每个属性的键值，就是各个字符组成的一个数组。</p>

<p>如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="c1">// []</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// []</span></code></pre></figure>

<h4 id="objectentries">Object.entries</h4>

<p>Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="s1">'bar'</span><span class="p">,</span> <span class="na">baz</span><span class="p">:</span> <span class="mi">42</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="c1">// [ ["foo", "bar"], ["baz", 42] ]</span></code></pre></figure>

<p>除了返回值不一样，该方法的行为与Object.values基本一致。</p>

<p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">({</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">()]:</span> <span class="mi">123</span><span class="p">,</span> <span class="na">foo</span><span class="p">:</span> <span class="s1">'abc'</span> <span class="p">});</span>
<span class="c1">// [ [ 'foo', 'abc' ] ]</span></code></pre></figure>

<p>上面代码中，原对象有两个属性，Object.entries只输出属性名非 Symbol 值的属性。将来可能会有Reflect.ownEntries()方法，返回对象自身的所有属性。</p>

<p>Object.entries的基本用途是遍历对象的属性。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">one</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">two</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">]</span> <span class="nx">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
    <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">k</span><span class="p">)}</span><span class="err">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">v</span><span class="p">)}</span><span class="err">`</span>
  <span class="p">);</span>
<span class="p">}</span>
<span class="c1">// "one": 1</span>
<span class="c1">// "two": 2</span></code></pre></figure>

<p>Object.entries方法的另一个用处是，将对象转为真正的Map结构。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="s1">'bar'</span><span class="p">,</span> <span class="na">baz</span><span class="p">:</span> <span class="mi">42</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span>
<span class="nx">map</span> <span class="c1">// Map { foo: "bar", baz: 42 }</span></code></pre></figure>

<p>自己实现Object.entries方法，非常简单。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// Generator函数的版本</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="nx">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 非Generator函数的版本</span>
<span class="kd">function</span> <span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="nx">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h3 id="section-7">10. 对象的扩展运算符</h3>

<p>《数组的扩展》一章中，已经介绍过扩展预算符（…）。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">a</span> <span class="c1">// 1</span>
<span class="nx">b</span> <span class="c1">// [2, 3]</span></code></pre></figure>

<p>ES2017 将这个运算符引入了对象。</p>

<p>（1）解构赋值</p>

<p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">z</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">a</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">4</span> <span class="p">};</span>
<span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">y</span> <span class="c1">// 2</span>
<span class="nx">z</span> <span class="c1">// { a: 3, b: 4 }</span></code></pre></figure>

<p>上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。</p>

<p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">z</span> <span class="p">}</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 运行时错误</span>
<span class="kd">let</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">z</span> <span class="p">}</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// 运行时错误</span></code></pre></figure>

<p>解构赋值必须是最后一个参数，否则会报错。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="p">{</span> <span class="p">...</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span> <span class="c1">// 句法错误</span>
<span class="kd">let</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="p">...</span><span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">z</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span> <span class="c1">// 句法错误</span></code></pre></figure>

<p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p>

<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">};</span>
<span class="kd">let</span> <span class="p">{</span> <span class="p">...</span><span class="nx">x</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// 2</span></code></pre></figure>

<p>上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p>

<p>另外，解构赋值不会拷贝继承自原型对象的属性。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">o1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="kd">let</span> <span class="nx">o2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="nx">o2</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">o1</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">o3</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">o2</span> <span class="p">};</span>
<span class="nx">o3</span> <span class="c1">// { b: 2 }</span></code></pre></figure>

<p>上面代码中，对象o3是o2的拷贝，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。</p>

<p>下面是另一个例子。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">2</span> <span class="p">});</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="kd">let</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="p">...{</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="p">}</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>
<span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">y</span> <span class="c1">// undefined</span>
<span class="nx">z</span> <span class="c1">// 3</span></code></pre></figure>

<p>上面代码中，变量x是单纯的解构赋值，所以可以读取继承的属性；解构赋值产生的变量y和z，只能读取对象自身的属性，所以只有变量z可以赋值成功。</p>

<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">baseFunction</span><span class="p">({</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">wrapperFunction</span><span class="p">({</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">restConfig</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// 使用x和y参数进行操作</span>
  <span class="c1">// 其余参数传给原始函数</span>
  <span class="k">return</span> <span class="nx">baseFunction</span><span class="p">(</span><span class="nx">restConfig</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>上面代码中，原始函数baseFunction接受a和b作为参数，函数wrapperFunction在baseFunction的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>

<p>（2）扩展运算符</p>

<p>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">z</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">4</span> <span class="p">};</span>
<span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">z</span> <span class="p">};</span>
<span class="nx">n</span> <span class="c1">// { a: 3, b: 4 }</span></code></pre></figure>

<p>这等同于使用Object.assign方法。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">aClone</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span> <span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">aClone</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">a</span><span class="p">);</span></code></pre></figure>

<p>扩展运算符可以用于合并两个对象。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">ab</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span> <span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">ab</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span></code></pre></figure>

<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">aWithOverrides</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span><span class="p">,</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">aWithOverrides</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span><span class="p">,</span> <span class="p">...{</span> <span class="nl">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">aWithOverrides</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">aWithOverrides</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">a</span><span class="p">,</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">2</span> <span class="p">});</span></code></pre></figure>

<p>上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。</p>

<p>这用来修改现有对象部分的部分属性就很方便了。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">newVersion</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">...</span><span class="nx">previousVersion</span><span class="p">,</span>
  <span class="na">name</span><span class="p">:</span> <span class="s1">'New Name'</span> <span class="c1">// Override the name property</span>
<span class="p">};</span></code></pre></figure>

<p>上面代码中，newVersion对象自定义了name属性，其他属性全部复制自previousVersion对象。</p>

<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">aWithDefaults</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...</span><span class="nx">a</span> <span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">aWithDefaults</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="nx">a</span><span class="p">);</span>
<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">aWithDefaults</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="nx">a</span><span class="p">);</span></code></pre></figure>

<p>扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。\</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 并不会抛出错误，因为x属性只是被定义，但没执行</span>
<span class="kd">let</span> <span class="nx">aWithXGetter</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">...</span><span class="nx">a</span><span class="p">,</span>
  <span class="nx">get</span> <span class="nx">x</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">throws</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'not thrown yet'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 会抛出错误，因为x属性被执行了</span>
<span class="kd">let</span> <span class="nx">runtimeError</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">...</span><span class="nx">a</span><span class="p">,</span>
  <span class="p">...{</span>
    <span class="nx">get</span> <span class="nx">x</span><span class="p">()</span> <span class="p">{</span>
      <span class="kr">throws</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'thrown now'</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>如果扩展运算符的参数是null或undefined，这个两个值会被忽略，不会报错。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">emptyObject</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="kc">null</span><span class="p">,</span> <span class="p">...</span><span class="kc">undefined</span> <span class="p">};</span> <span class="c1">// 不报错</span></code></pre></figure>

<h3 id="objectgetownpropertydescriptors">11. Object.getOwnPropertyDescriptors()</h3>

<p>ES5有一个Object.getOwnPropertyDescriptor方法，返回某个对象属性的描述对象（descriptor）。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="s1">'a'</span> <span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">'p'</span><span class="p">)</span>
<span class="c1">// Object { value: "a",</span>
<span class="c1">//   writable: true,</span>
<span class="c1">//   enumerable: true,</span>
<span class="c1">//   configurable: true</span>
<span class="c1">// }</span></code></pre></figure>

<p>ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">foo</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="nx">get</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s1">'abc'</span> <span class="p">}</span>
<span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="c1">// { foo:</span>
<span class="c1">//    { value: 123,</span>
<span class="c1">//      writable: true,</span>
<span class="c1">//      enumerable: true,</span>
<span class="c1">//      configurable: true },</span>
<span class="c1">//   bar:</span>
<span class="c1">//    { get: [Function: bar],</span>
<span class="c1">//      set: undefined,</span>
<span class="c1">//      enumerable: true,</span>
<span class="c1">//      configurable: true } }</span></code></pre></figure>

<p>上面代码中，Object.getOwnPropertyDescriptors方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>

<p>该方法的实现非常容易。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="nx">of</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">source</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">set</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">target1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target1</span><span class="p">,</span> <span class="nx">source</span><span class="p">);</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">target1</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">)</span>
<span class="c1">// { value: undefined,</span>
<span class="c1">//   writable: true,</span>
<span class="c1">//   enumerable: true,</span>
<span class="c1">//   configurable: true }</span></code></pre></figure>

<p>上面代码中，source对象的foo属性的值是一个赋值函数，Object.assign方法将这个属性拷贝给target1对象，结果该属性的值变成了undefined。这是因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p>

<p>这时，Object.getOwnPropertyDescriptors方法配合Object.defineProperties方法，就可以实现正确拷贝。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">source</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">set</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">target2</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">(</span><span class="nx">target2</span><span class="p">,</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">source</span><span class="p">));</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">target2</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">)</span>
<span class="c1">// { get: undefined,</span>
<span class="c1">//   set: [Function: foo],</span>
<span class="c1">//   enumerable: true,</span>
<span class="c1">//   configurable: true }</span></code></pre></figure>

<p>上面代码中，将两个对象合并的逻辑提炼出来，就是下面这样。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">shallowMerge</span> <span class="o">=</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">(</span>
  <span class="nx">target</span><span class="p">,</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span>
<span class="p">);</span></code></pre></figure>

<p>Object.getOwnPropertyDescriptors方法的另一个用处，是配合Object.create方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">clone</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span>

<span class="c1">// 或者</span>

<span class="kr">const</span> <span class="nx">shallowClone</span> <span class="o">=</span> <span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="p">);</span></code></pre></figure>

<p>上面代码会克隆对象obj。</p>

<p>另外，Object.getOwnPropertyDescriptors方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">__proto__</span><span class="p">:</span> <span class="nx">prot</span><span class="p">,</span>
  <span class="na">foo</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
<span class="p">};</span></code></pre></figure>

<p>ES6 规定__proto__只有浏览器要部署，其他环境不用部署。如果去除__proto__，上面代码就要改成下面这样。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">prot</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>

<span class="c1">// 或者</span>

<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">prot</span><span class="p">),</span>
  <span class="p">{</span>
    <span class="na">foo</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">);</span></code></pre></figure>

<p>有了Object.getOwnPropertyDescriptors，我们就有了另一种写法。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
  <span class="nx">prot</span><span class="p">,</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">({</span>
    <span class="na">foo</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="p">})</span>
<span class="p">);</span></code></pre></figure>

<p>Object.getOwnPropertyDescriptors也可以用来实现 Mixin（混入）模式。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">mix</span> <span class="o">=</span> <span class="p">(</span><span class="nx">object</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
  <span class="na">with</span><span class="p">:</span> <span class="p">(...</span><span class="nx">mixins</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">mixins</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">mixin</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
      <span class="nx">c</span><span class="p">,</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">mixin</span><span class="p">)</span>
    <span class="p">),</span> <span class="nx">object</span><span class="p">)</span>
<span class="p">});</span>

<span class="c1">// multiple mixins example</span>
<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="s1">'a'</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span><span class="na">b</span><span class="p">:</span> <span class="s1">'b'</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">{</span><span class="na">c</span><span class="p">:</span> <span class="s1">'c'</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">c</span><span class="p">).</span><span class="kd">with</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span></code></pre></figure>

<p>上面代码中，对象a和b被混入了对象c。</p>

<p>出于完整性的考虑，Object.getOwnPropertyDescriptors进入标准以后，还会有Reflect.getOwnPropertyDescriptors方法。</p>

<h3 id="null-">12. Null 传导运算符</h3>

<p>编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取message.body.user.firstName，安全的写法是写成下面这样。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="p">(</span><span class="nx">message</span>
  <span class="o">&amp;&amp;</span> <span class="nx">message</span><span class="p">.</span><span class="nx">body</span>
  <span class="o">&amp;&amp;</span> <span class="nx">message</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">user</span>
  <span class="o">&amp;&amp;</span> <span class="nx">message</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">firstName</span><span class="p">)</span> <span class="o">||</span> <span class="s1">'default'</span><span class="p">;</span></code></pre></figure>

<p>这样的层层判断非常麻烦，因此现在有一个提案，引入了“Null 传导运算符”（null propagation operator）?.，简化上面的写法。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="nx">message</span><span class="p">?.</span><span class="nx">body</span><span class="p">?.</span><span class="nx">user</span><span class="p">?.</span><span class="nx">firstName</span> <span class="o">||</span> <span class="s1">'default'</span><span class="p">;</span></code></pre></figure>

<p>上面代码有三个?.运算符，只要其中一个返回null或undefined，就不再往下运算，而是返回undefined。</p>

<p>“Null 传导运算符”有四种用法。</p>

<p>obj?.prop // 读取对象属性
obj?.[expr] // 同上
func?.(…args) // 函数或对象方法的调用
new C?.(…args) // 构造函数的调用
传导运算符之所以写成obj?.prop，而不是obj?prop，是为了方便编译器能够区分三元运算符?:（比如obj?prop:123）。</p>

<p>下面是更多的例子。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 如果 a 是 null 或 undefined, 返回 undefined</span>
<span class="c1">// 否则返回 a.b.c().d</span>
<span class="nx">a</span><span class="p">?.</span><span class="nx">b</span><span class="p">.</span><span class="nx">c</span><span class="p">().</span><span class="nx">d</span>

<span class="c1">// 如果 a 是 null 或 undefined，下面的语句不产生任何效果</span>
<span class="c1">// 否则执行 a.b = 42</span>
<span class="nx">a</span><span class="p">?.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">42</span>

<span class="c1">// 如果 a 是 null 或 undefined，下面的语句不产生任何效果</span>
<span class="k">delete</span> <span class="nx">a</span><span class="p">?.</span><span class="nx">b</span></code></pre></figure>


  </div>

</article>
<!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="/front/article/2017/03/17/es6-8" data-title="ES6语法之八（对象的扩展）" data-url="/front/article/2017/03/17/es6-8.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"lq1228"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
<!-- 多说公共JS代码 end -->

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="friend-link">
        <div class="friend-title">友情链接</div>
        
            <a href="https://bystep15.github.io/">
		宝宝树前端团队博客
	    </a>
	
            <a href="http://testudy.cc/">
		胡继伟
	    </a>
	
            <a href="https://yj1438.github.io/">
		尹杰
	    </a>
	
            <a href="https://github.com/cnsnake11/blog">
		曹楠
	    </a>
	
            <a href="http://www.jianshu.com/users/b7dc4381aed3/">
		姚琪
	    </a>
	
            <a href="https://lilywei739.github.io">
		魏莉
	    </a>
	
            <a href="https://wangjiaoxia.github.io/">
		王娇霞
	    </a>
	
            <a href="http://www.ushtml.com/">
		武明礼
	    </a>
	
            <a href="http://kouyun.me/">
		寇云
	    </a>
	
            <a href="http://brooch.me/">
		郑星宬
	    </a>
	
            <a href="http://zhanyouwei.com/">
		占友伟
	    </a>
	
            <a href="">
		
	    </a>
	
    </div>

    <div class="copyright">
      <p>lq1228.github.io</p>
    </div>

  </div>

</footer>


  </body>

</html>
