<p>随着JavaScript的单页应用的要求变得越来越复杂，我们的代码必须比以往管理更多的状态。其中既包含服务器响应和缓存数据，也包括由本地创建尚未持久化到服务器端的数据。同时UI状态也越发复杂，我们必须管理路由激活，选项卡选择，进度条，分页控件，等等。</p>

<p>管理不断变化的状态非常困难。如果一个模型可以更新另一个模型，一个视图也可以更新一个模型，这个模型又更新了另一个模型，反过来这又导致了其他视图的更新。在某些情况下，你难于理解程序发生了什么，不知道它的状态在什么时候，什么原因又如何发生了变化。当系统变得不足够透明并充满不确定性时，重现和解决Bug将变得非常困难，也难于添加新的需求。</p>

<p>似乎这还不是全部问题，鉴于在前端产品开发中不断加入的新需求，作为开发者，我们期望实现高性能更新，服务器端渲染，在路由跳转之前获得数据，等等其他任务。我们突然发现自己要处理的工作已经变得前所未有的复杂，此时不可避免的会有一个想法：是否到了放弃的时候？，答案当然是NO。</p>

<p>这种复杂性很难处理，因为它混合的两个概念对人类来说都非常难于理解：变化和异步。我将它们称为可乐加曼妥思喷发现象。两个问题分开时都可以漂亮的解决，但一起出现后就变成了一团乱麻。React之类的库中同时删除了异步和DOM的直接操作来解决视图层中的这个问题。但管理状态数据则取决于你自己，这也是Redux出现的原因。</p>

<p>逐步跟随Flux，CQRS和Event Sourcing改进的基础上，通过严格限制更新发生的时机和方式，使得Redux中可以预测状态的变化，这种限制集中体现在Redux的<a href="https://lq1228.github.io/front/article/2017/06/16/redux4.html">三大原则</a>中。</p>
